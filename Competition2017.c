#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in2,    LPot,           sensorPotentiometer)
#pragma config(Sensor, in3,    RPot,           sensorPotentiometer)
#pragma config(Sensor, in4,    AutoPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl4,  RLED,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  YLED,           sensorLEDtoVCC)
#pragma config(Sensor, I2C_1,  backLeftIEM,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  frontLeftIEM,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  frontRightIEM,  sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  backRightIEM,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           backRight,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           LScoop,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           RScoop,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armLT,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           armLB,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           armRT,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           armRB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          backLeft,      tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

//all the wheels stop moving
void still()
{
	motor[frontRight] = motor[backLeft]
	= motor[frontLeft]
	= motor[backRight] = 0;
}

//everything shuts off
void die()
{
	still();
	motor[armLT]	= motor[armLB]
								= motor[armRT]
								= motor[armRB] = 0;
}

int side = 1; //1 for start on right blue side, -1 for left side


//moves the robot forward (f),backward (b),left(l), or right(r)
//distance is in inches
void move(char dir, int speed, int distance)
{
	//assume CW is + and CCW is -

	resetMotorEncoder(backRight);
	resetMotorEncoder(frontRight);
	resetMotorEncoder(backLeft);
	resetMotorEncoder(frontLeft);

	int x = (150/(4*PI))*sqrt(2)*distance;
	switch (dir)
	{
	 case 'f':
	 	while(nMotorEncoder[backRight] > -x)
		{
			motor[frontRight] = motor[backRight]  = -speed;
			motor[frontLeft]  = motor[backLeft] = -speed;
		}
	  break;
	 case 'b':
	 	while(nMotorEncoder[backRight] < x)
		{
			motor[frontRight] = motor[backRight]  = speed;
			motor[frontLeft]  = motor[backLeft] = speed;
		}
		break;
	 case 'r':
	 	while((nMotorEncoder[backRight] > -x))
		{

				//motor[frontRight] = motor[backLeft]  = speed;
				//motor[frontLeft]  = motor[backRight] = -speed;

					float average = abs(nMotorEncoder[frontRight]) + abs(nMotorEncoder[frontLeft]) + abs(nMotorEncoder[backRight]) + abs(nMotorEncoder[backLeft]);
					average = average / 4;


					if((nMotorEncoder[frontRight]!=0)&&(nMotorEncoder[frontLeft]!=0)&&(nMotorEncoder[backLeft]!=0)&&(nMotorEncoder[backRight]!=0))
					{
						motor[frontRight] = (int)(((float)speed*abs(average/((float)abs(nMotorEncoder[frontRight])+(float)1))));
						motor[backLeft] = (int)(((float)speed*abs(average/((float)abs(nMotorEncoder[backLeft])+(float)1))));
						motor[frontLeft] = (int)(-((float)speed*abs(average/((float)abs(nMotorEncoder[frontLeft])+(float)1))));
						motor[backRight] = (int)(-((float)speed*abs(average/((float)abs(nMotorEncoder[backRight])+(float)1))));
					}
					else
					{
						motor[frontRight] = motor[backLeft]  = -30;
						motor[frontLeft]  = motor[backRight] = 30;
					}

		/*	if((abs(nMotorEncoder[frontRight]) - abs(nMotorEncoder[backRight]))<20)
			{
				motor[frontRight] = motor[backLeft]  = speed;
				motor[frontLeft]  = motor[backRight] = -speed;
			}
			else if(abs(nMotorEncoder[backRight])>abs(nMotorEncoder[frontRight]))
			{
				motor[frontRight] = motor[backLeft]  = speed;
				motor[frontLeft]  = -speed;
				motor[backRight] = -speed*0.5;//(1-(abs(nMotorEncoder[frontRight])/abs(nMotorEncoder[backRight])));
			}
			else
			{
				motor[frontRight] = speed*0.5;
				motor[backLeft]  = speed;//(1-(abs(nMotorEncoder[backRight])/abs(nMotorEncoder[frontRight])));
				motor[frontLeft]  = motor[backRight] = -speed;
			}*/

		}
		break;
	 case 'l':
	 	while(nMotorEncoder[backRight] < x)
		{
//			motor[frontRight] = motor[backLeft]  = -speed;
//			motor[frontLeft]  = motor[backRight] = speed;

				/*int greatest = 0;
				int least = 0;
				int average = 0;

				greatest = abs(nMotorEncoder[frontRight]);
				if(abs(nMotorEncoder[frontLeft])>greatest)
					greatest = abs(nMotorEncoder[frontLeft]);
				if(abs(nMotorEncoder[backLeft])>greatest)
						greatest = abs(nMotorEncoder[backLeft]);
				if(abs(nMotorEncoder[backRight])>greatest)
						greatest = abs(nMotorEncoder[backRight]);

				least = abs(nMotorEncoder[frontRight]);
				if(abs(nMotorEncoder[frontLeft])<least)
					least = abs(nMotorEncoder[frontLeft]);
				if(abs(nMotorEncoder[backLeft])<least)
					least = abs(nMotorEncoder[backLeft]);
				if(abs(nMotorEncoder[backRight])<least)
					least = abs(nMotorEncoder[backRight]);*/

				//average = abs(least+((greatest-least)/2));
					float average = abs(nMotorEncoder[frontRight]) + abs(nMotorEncoder[frontLeft])
						+ abs(nMotorEncoder[backRight]) + abs(nMotorEncoder[backLeft]);
					average = average / 4;


					if((nMotorEncoder[frontRight]!=0)&&(nMotorEncoder[frontLeft]!=0)&&(nMotorEncoder[backLeft]!=0)&&(nMotorEncoder[backRight]!=0))
					{
						motor[frontRight] = (int)(-((float)speed*abs(average/((float)abs(nMotorEncoder[frontRight])+(float)1))));
						motor[backLeft] = (int)(-((float)speed*abs(average/((float)abs(nMotorEncoder[backLeft])+(float)1))));
						motor[frontLeft] = (int)(((float)speed*abs(average/((float)abs(nMotorEncoder[frontLeft])+(float)1))));
						motor[backRight] = (int)(((float)speed*abs(average/((float)abs(nMotorEncoder[backRight])+(float)1))));
					}
					else
					{
						motor[frontRight] = motor[backLeft]  = -30;
						motor[frontLeft]  = motor[backRight] = 30;
					}

			/*if(abs(nMotorEncoder[backLeft])<abs(nMotorEncoder[frontLeft]))
			{
				motor[frontRight] = motor[backLeft]  = -speed;
				motor[backRight]  = speed;
				motor[frontLeft] = speed*((abs(nMotorEncoder[backLeft])/abs(nMotorEncoder[frontLeft])));
			}
			else if(abs(nMotorEncoder[frontLeft])==0)
			{
			motor[frontRight] = motor[backLeft]  = -speed;
			motor[frontLeft]  = motor[backRight] = speed;
			wait1Msec(100);
			}
			else
			{
				motor[frontRight] = -speed;
				motor[backLeft]  = -speed*((abs(nMotorEncoder[frontLeft])/abs(nMotorEncoder[backLeft])));
				motor[frontLeft]  = motor[backLeft] = speed;
			}*/
		}
		break;
	 default:
	   still();
	 }
	 still();
}

//makes the robot turn left (l) or right (r)
void turn(char dir, float angle)
{
	//assume CW/+ and CCW/-
	if(dir!='l' && dir!='r')
		return;

	float scale = (dir=='l')?(1):(-1);
	scale = scale *0.5;
	motor[frontRight] = motor[backRight] = -scale*127;
	motor[frontLeft] = motor[backLeft] = scale*127;

	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[frontLeft] = 0;
	nMotorEncoder[frontRight] = 0;
	nMotorEncoder[backRight] = 0;
	clearDebugStream();

	float encoder_to_angle = 0.21;//183673	//Obtained via testing
	float slow_tolerance = 0.5;	//Percentage of angle at which to start slowing
	//0.2 and 0.0 works for 90*, 0.21 and 0.8 works for 180*

	while(abs(nMotorEncoder[backLeft])*encoder_to_angle<angle*slow_tolerance)
	{
		wait1Msec(10);	//GO FULL SPEED! VALHALLA AWAITS!
	}

	while(abs(nMotorEncoder[backLeft])*encoder_to_angle<angle)
	{
		//Let's start slowing down
		//Motors now go slower as they approach the wanted angle
		float modSpeed = (1.3-((abs(nMotorEncoder[backLeft])*encoder_to_angle)/angle))*127;
		writeDebugStream("modSpeed = %d, %d\n",modSpeed,(((abs(nMotorEncoder[backLeft])*encoder_to_angle)/angle))*127);
		//if(modSpeed < 20) modSpeed = 25;
		motor[frontRight] = motor[backRight] = -scale*modSpeed;
		motor[frontLeft] = motor[backLeft] = scale*modSpeed;
	}
	still();
}

/*allows the robot to move diagonally to the
forward right (fr), forward left (fl)
backward right (br) or backward left (bl)
*/
void diag(string dir, int speed, int time)
{
	//assume CW/+ and CCW/-
	if(strcmp(dir,"fl") == 0)
	{
		motor[frontRight] = motor[backLeft] = -speed;
		motor[backRight] = motor[frontLeft] = 0;
		wait1Msec(time);
	}
	else if (strcmp(dir,"fr") == 0)
	{
		motor[frontRight] = motor[backLeft] = 0;
		motor[backRight] = motor[frontLeft] = -speed;
		wait1Msec(time);
	}
	else if (strcmp(dir,"bl") == 0)
	{
		motor[frontRight] = motor[backLeft] = 0;
		motor[backRight] = motor[frontLeft] = speed;
		wait1Msec(time);
	}
	else if (strcmp(dir,"br") == 0)
	{
		motor[frontRight] = motor[backLeft] = speed;
		motor[backRight] = motor[frontLeft] = 0;
		wait1Msec(time);
	}
	still();
}

//move the arm
void arm(int speed, int distance)
{
	//Left Potentiometer and Right Potentiometer reads
	int LP = SensorValue[LPot];
	int RP = SensorValue[RPot];
	int diff = abs(LP-RP);
	int modSpeed = speed - ((float)diff)/10;
	if(modSpeed < 20)
		modSpeed = 0;
	if(diff < 10)
		modSpeed = speed;

	//Arm moving
	//2000 yields halfway, 3000 yields top, 1250 yields bottom
	while(SensorValue[LPot] < distance)
	{
		if((LP > RP) || (LP < RP))
		{
			motor[armRT] = motor[armRB] = speed;
			motor[armLT] = motor[armLB] = modSpeed;
		}
		//In the case that the right pot equals the left pot,
		//modSpeed is already equal to setSpeed, so nothing is slowed anyway
		else
		{
			motor[armRT] = motor[armRB] = modSpeed;
			motor[armLT] = motor[armLB] = speed;
		}

	}
	while(SensorValue[LPot] > distance)
	{
		if((LP > RP) || (LP < RP))
		{
			motor[armRT] = motor[armRB] = -speed;
			motor[armLT] = motor[armLB] = -modSpeed;
		}
		else
		{
			motor[armRT] = motor[armRB] = -modSpeed;
			motor[armLT] = motor[armLB] = -speed;
		}
	}
	motor[armRT] = motor[armRB] = 0;
	motor[armLT] = motor[armLT] = 0;
}

//close and open the claw
//use a time variable in case the claw
//is not all of the way open/closed. Is
//there a better way to do this?
//limit switch?
//input -1 for close and +1 for open
//500 time = 1/2, 1000 time = 1
void claw(int dir, int time)
{
	motor[LScoop] = motor[RScoop] = dir*128;
	wait1Msec(time);
	motor[LScoop] = motor[RScoop] = 0;
}



/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{

	//if(SensorValue[LPot] != 1250) arm(60,1250);

	//SensorValue[RLED] = 0;
	//SensorValue[YLED] = 0;

	//if(SensorValue[AutoPot] > 2048)
	//{
	//	//Right
	//	SensorValue[RLED] = 1;
	//	arm(60,2500);
	//	move('f',100,20);
	//	wait1Msec(300);
	//	move('r',40,2);
	//	move('r',80,20);
	//	move('f',100,30);
	//	claw(-1,1200);
	//	move('l',100,60);
	//	move('l',100,40);
	//	//claw(1,500);
	//}
	//else
	//{
	//	//Left
	//	SensorValue[YLED] = 1;
	//	arm(60,2500);
	//	move('f',100,20);
	//	wait1Msec(300);
	//	move('l',40,2);
	//	move('l',80,20);
	//	move('f',100,30);
	//	claw(-1,1200);
	//	move('r',100,60);
	//	move('r',100,40);
	//	//claw(1,500);
	//}
	//SensorValue[RLED] = 0;
	//SensorValue[YLED] = 0;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{
  	int X2 = 0, Y1 = 0, X1 = 0, threshold1 = 15, threshold2 = 10;
	int setSpeed = 80;
	int LP, RP, diff;
	//Loop Forever
	while(1 == 1)
	{
		//Create "deadzone" for Y1/Ch3
		if(abs(vexRT[Ch3]) > threshold1)
			Y1 = -vexRT[Ch3];
		else
			Y1 = 0;
		//Create "deadzone" for X1/Ch4
		if(abs(vexRT[Ch4]) > threshold1)
			X1 = -vexRT[Ch4];
		else
			X1 = 0;
		//Create "deadzone" for X2/Ch1
		if(abs(vexRT[Ch1]) > threshold1)
			X2 = vexRT[Ch1];
		else
			X2 = 0;

		//Remote Control Commands for Wheels
		motor[frontRight] = Y1 + X2 - X1;//Ch3-Ch1-Ch4
		motor[backRight] =  Y1 + X2 + X1;//Ch3-Ch1+Ch4
		motor[frontLeft] = Y1 - X2 + X1;//Ch3+Ch1+Ch4
		motor[backLeft] =  Y1 - X2 - X1;//Ch3+Ch1-Ch4

		//Moving the Arm

		//Left Potentiometer and Right Potentiometer reads
		LP = SensorValue[LPot];
		RP = SensorValue[RPot];
		diff = abs(LP - RP);

		//The modSpeed is the reduced speed of the motor
		//If the modSpeed is less than five, stop the motor to stop whining
		//If the difference of the potentiometers is less than the threshold, use the original speed
		int modSpeed = setSpeed - ((float)diff)/10;
		if(modSpeed < 20)
			modSpeed = 0;
		if(diff < threshold2)
			modSpeed = setSpeed;

		//Arm going up
		if(vexRT[Btn6U])
		{
			//If the left arm is ahead of the right arm, slow down the left arm
			if(LP > RP)
			{
				motor[armRT] = motor[armRB] = setSpeed;
				motor[armLT] = motor[armLB] = modSpeed;
			}
			//If the right arm is ahead of the left, slow down the right
			//In the case that the right pot equals the left pot,
			//modSpeed is already equal to setSpeed, so nothing is slowed anyway
			else
			{
				motor[armRT] = motor[armRB] = modSpeed;
				motor[armLT] = motor[armLB] = setSpeed;
			}
		}
		//Arm going down
		else if (vexRT[Btn6D])
		{
			//If the left arm is ahead of the right arm, slow down the left arm.
			//Note that since we are going down, the left pot being less than the
			//right pot means that the left one is going faster than the right.
			if(LP < RP)
			{
				motor[armRT] = motor[armRB] = -setSpeed;
				motor[armLT] = motor[armLB] = -modSpeed;
			}
			//If the right arm is ahead of the left, slow down the right
			//In the case that the right pot equals the left pot,
			//modSpeed is already equal to speed[3], so nothing is slowed anyway
			else
			{
				motor[armRT] = motor[armRB] = -modSpeed;
				motor[armLT] = motor[armLB] = -setSpeed;
			}
		}
		//Arm stops
		else
		{
			motor[armRT] = motor[armRB] = 0;
			motor[armLT] = motor[armLB] = 0;
		}

		//Moving the Scoop
		if(vexRT[Btn5U])
			motor[LScoop] = motor[RScoop] = setSpeed;
		else if(vexRT[Btn5D])
			motor[LScoop] = motor[RScoop] = -setSpeed;
		else
			motor[LScoop] = motor[RScoop] = 0;

		//Presets-for changing speed
		if(vexRT[Btn7U])//turn left
		{
			motor[frontRight] = motor[backRight] = -setSpeed;
			motor[frontLeft]  = motor[backLeft]  = setSpeed;
		}
		else if(vexRT[Btn7D])//turn right
		{
			motor[frontRight] = motor[backRight] = setSpeed;
			motor[frontLeft]  = motor[backLeft]  = -setSpeed;
		}

//	setSpeed = 127;
		//else if(vexRT[Btn7L])
		//	setSpeed = 64;
		//else if(vexRT[Btn7R])
		//	setSpeed = 17;//96

		//Claw
		if(vexRT[Btn8U])
			motor[armLB] = 64;
		else if(vexRT[Btn8D])
			motor[armLB] = -64;
		else
			motor[armLB] = 0;

	}
}
