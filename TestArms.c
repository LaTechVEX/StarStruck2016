#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in2,    LPot,           sensorPotentiometer)
#pragma config(Sensor, in3,    RPot,           sensorPotentiometer)
#pragma config(Sensor, I2C_1,  backLeftIEM,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  frontLeftIEM,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  frontRightIEM,  sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  backRightIEM,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           backRight,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           LScoop,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           RScoop,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armLT,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           armLB,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           armRT,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           armRB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          backLeft,      tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	//Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
	int X2 = 0, Y1 = 0, X1 = 0, threshold1 = 15, threshold2 = 10;
	int setSpeed = 80;
	int LP, RP, diff;
	//Loop Forever
	while(1 == 1)
	{
		//Create "deadzone" for Y1/Ch3
		if(abs(vexRT[Ch3]) > threshold1)
			Y1 = -vexRT[Ch3];
		else
			Y1 = 0;
		//Create "deadzone" for X1/Ch4
		if(abs(vexRT[Ch4]) > threshold1)
			X1 = -vexRT[Ch4];
		else
			X1 = 0;
		//Create "deadzone" for X2/Ch1
		if(abs(vexRT[Ch1]) > threshold1)
			X2 = vexRT[Ch1];
		else
			X2 = 0;

		//Remote Control Commands for Wheels
		motor[frontRight] = Y1 + X2 - X1;//Ch3-Ch1-Ch4
		motor[backRight] =  Y1 + X2 + X1;//Ch3-Ch1+Ch4
		motor[frontLeft] = Y1 - X2 + X1;//Ch3+Ch1+Ch4
		motor[backLeft] =  Y1 - X2 - X1;//Ch3+Ch1-Ch4

		//Moving the Arm

		//Left Potentiometer and Right Potentiometer reads
		LP = SensorValue[LPot];
		RP = SensorValue[RPot];
		diff = abs(LP - RP);

		//The modSpeed is the reduced speed of the motor
		//If the modSpeed is less than five, stop the motor to stop whining
		//If the difference of the potentiometers is less than the threshold, use the original speed
		int modSpeed = setSpeed - ((float)diff)/10;
		if(modSpeed < 20)
			modSpeed = 0;
		if(diff < threshold2)
			modSpeed = setSpeed;

		//Arm going up
		if(vexRT[Btn6U])
		{
			//If the left arm is ahead of the right arm, slow down the left arm
			if(LP > RP)
			{
				motor[armRT] = motor[armRB] = setSpeed;
				motor[armLT] = motor[armLB] = modSpeed;
			}
			//If the right arm is ahead of the left, slow down the right
			//In the case that the right pot equals the left pot,
			//modSpeed is already equal to setSpeed, so nothing is slowed anyway
			else
			{
				motor[armRT] = motor[armRB] = modSpeed;
				motor[armLT] = motor[armLB] = setSpeed;
			}
		}
		//Arm going down
		else if (vexRT[Btn6D])
		{
			//If the left arm is ahead of the right arm, slow down the left arm.
			//Note that since we are going down, the left pot being less than the
			//right pot means that the left one is going faster than the right.
			if(LP < RP)
			{
				motor[armRT] = motor[armRB] = -setSpeed;
				motor[armLT] = motor[armLB] = -modSpeed;
			}
			//If the right arm is ahead of the left, slow down the right
			//In the case that the right pot equals the left pot,
			//modSpeed is already equal to speed[3], so nothing is slowed anyway
			else
			{
				motor[armRT] = motor[armRB] = -modSpeed;
				motor[armLT] = motor[armLB] = -setSpeed;
			}
		}
		//Arm stops
		else
		{
			motor[armRT] = motor[armRB] = 0;
			motor[armLT] = motor[armLB] = 0;
		}

		//Moving the Scoop
		if(vexRT[Btn5U])
			motor[LScoop] = motor[RScoop] = setSpeed;
		else if(vexRT[Btn5D])
			motor[LScoop] = motor[RScoop] = -setSpeed;
		else
			motor[LScoop] = motor[RScoop] = 0;

		//Presets-for changing speed
		if(vexRT[Btn7U])//turn left
		{
			motor[frontRight] = motor[backRight] = -setSpeed;
			motor[frontLeft]  = motor[backLeft]  = setSpeed;
		}
		else if(vexRT[Btn7D])//turn right
		{
			motor[frontRight] = motor[backRight] = setSpeed;
			motor[frontLeft]  = motor[backLeft]  = -setSpeed;
		}

//	setSpeed = 127;
		//else if(vexRT[Btn7L])
		//	setSpeed = 64;
		//else if(vexRT[Btn7R])
		//	setSpeed = 17;//96

		//Claw
		if(vexRT[Btn8U])
			motor[armLB] = 64;
		else if(vexRT[Btn8D])
			motor[armLB] = -64;
		else
			motor[armLB] = 0;

	}


}
