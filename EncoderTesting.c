#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in2,    LPot,           sensorPotentiometer)
#pragma config(Sensor, in3,    RPot,           sensorPotentiometer)
#pragma config(Sensor, I2C_1,  backLeftIEM,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  frontLeftIEM,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  frontRightIEM,  sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  backRightIEM,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           backRight,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           LScoop,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           RScoop,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armLT,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           armLB,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           armRT,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           armRB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          backLeft,      tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Basic Encoder Controls
----------------------------------------------------------------------------------------------------*/

//makes the robot turn left (l) or right (r)
//void turn(char dir, float angle)
//{
//	//assume CW/+ and CCW/-
//	if(dir!='l' && dir!='r')
//		return;

//	nMotorEncoder[backLeft] = 0;
//	nMotorEncoder[frontLeft] = 0;
//	nMotorEncoder[frontRight] = 0;
//	nMotorEncoder[backRight] = 0;
//}


task main()
{
//	wait1Msec(5000);
//	turn('l',90);
//	wait1Msec(2000);

	resetMotorEncoder(backLeft);
	resetMotorEncoder(backRight);
	resetMotorEncoder(frontLeft);
	resetMotorEncoder(frontRight);

	wait1Msec(2000);

	motor[backLeft] = motor[frontLeft] = -30;
	motor[backRight] = motor[frontRight] = 30;

	clearDebugStream();
	while((nMotorEncoder[backRight] 	< 200)		||
				(nMotorEncoder[frontRight] < 200) 	||
				(nMotorEncoder[backLeft] 	> -200)	||
				(nMotorEncoder[frontLeft] 	> -200))
				{
					if(nMotorEncoder[backRight] >= 200) motor[backRight] = 0;
					if(nMotorEncoder[frontRight] >= 200) motor[frontRight] = 0;
					if(nMotorEncoder[backLeft] <=-200) motor[backLeft] = 0;
					if(nMotorEncoder[frontLeft] <= -200) motor[frontLeft] = 0;
			}
	resetMotorEncoder(backLeft);
	resetMotorEncoder(backRight);
	resetMotorEncoder(frontLeft);
	resetMotorEncoder(frontRight);
	motor[backRight] = motor[frontRight] = motor[backLeft] = motor[frontLeft] = 0;

}
